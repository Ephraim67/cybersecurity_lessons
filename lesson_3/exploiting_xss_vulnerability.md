### **Step-by-Step XSS Testing Approach**
#### **1. Identify Input Points**
- Choose a **unique, arbitrary string** (e.g., `myxsstestdmqlwp`) that is unlikely to be affected by filters.
- Submit this string **one parameter at a time** across different pages.
- Monitor responses to see where the string appears.

#### **2. Analyze Reflected Inputs**
- If the string appears **unchanged** in the response, that parameter may be a candidate for XSS.
- If the string is **partially modified**, check if filtering or encoding is being applied.
- Test **both GET and POST** request parameters.

#### **3. Evading Filters**
- Try variations of payloads:
  - **Encoding bypass**: URL encoding (`%3Cscript%3E`), Unicode encoding, HTML entities.
  - **Breaking filters**: Using different JavaScript event handlers (`onerror=alert(1)`, `onclick=alert(1)`, etc.).
  - **Tag obfuscation**: `<img src=x onerror=alert(1)>`, `<svg onload=alert(1)>`.

#### **4. Testing HTTP Headers**
- Some applications reflect data from HTTP headers into responses. Test:
  - **Referer:** Inject payloads into `Referer: <script>alert(1)</script>`
  - **User-Agent:** Inject `<script>alert(1)</script>` into `User-Agent: Mozilla/5.0 <script>alert(1)</script>`
  - **Cookie/Header-based XSS:** If headers are reflected without proper sanitization, they can be an attack vector.

#### **5. Testing Different Contexts**
- **JavaScript Context**: Inject `";alert(1);//` inside `<script>` blocks.
- **HTML Context**: `<img src=x onerror=alert(1)>`
- **Attribute Context**: `"><svg onload=alert(1)>`
- **CSS Context**: `</style><script>alert(1)</script>`

#### **6. Automating with Burp Suite**
- Use Burp Suite’s **Intruder** to automate fuzzing.
- Use **"Change request method"** to test if a POST-based XSS works via GET.
- Use Burp’s **Active Scanner** to identify potential XSS vulnerabilities.

#### **7. Proof-of-Concept (PoC)**
- If successful, craft a PoC URL or payload.
- Try **DOM-based XSS** by injecting payloads into URLs and checking if they execute within the browser console.


**Nuclei template** for detecting reflected XSS vulnerabilities. This template injects test payloads into various parameters and checks if they are reflected in the response.  

---

### **Nuclei XSS Detection Template**
```yaml
id: xss-reflected

info:
  name: Reflected XSS Detection
  author: CyberSecPentester
  severity: high
  description: "Detects reflected XSS vulnerabilities by injecting test payloads and checking response reflections."
  tags: xss, injection, web, security

variables:
  xss_payload: "<script>alert(1)</script>"

requests:
  - method: GET
    path:
      - "{{BaseURL}}"
      - "{{BaseURL}}?q={{xss_payload}}"
      - "{{BaseURL}}?search={{xss_payload}}"
      - "{{BaseURL}}?id={{xss_payload}}"
      - "{{BaseURL}}?query={{xss_payload}}"

    matchers:
      - type: word
        words:
          - "<script>alert(1)</script>"
        part: body

  - method: POST
    path:
      - "{{BaseURL}}"
    body: "username={{xss_payload}}&password=test"

    headers:
      Content-Type: application/x-www-form-urlencoded

    matchers:
      - type: word
        words:
          - "<script>alert(1)</script>"
        part: body

  - method: GET
    path:
      - "{{BaseURL}}"

    headers:
      User-Agent: "{{xss_payload}}"
      Referer: "{{xss_payload}}"

    matchers:
      - type: word
        words:
          - "<script>alert(1)</script>"
        part: body
```

---

### **How to Use This Template**
1. **Save the template** as `xss-reflected.yaml` in the Nuclei templates directory.
2. **Run the scan** using:
   ```bash
   nuclei -t xss-reflected.yaml -u http://target.com
   ```
3. **Analyze the results** to confirm vulnerable parameters.

---

This template covers:
✅ **GET and POST parameter injection**  
✅ **Testing `User-Agent` and `Referer` headers**  
✅ **Checking reflected payloads in the response** 
